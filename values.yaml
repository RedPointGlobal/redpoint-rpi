global:
  application:
    name: redpoint-interaction
    version: "7.2"
    environment: prod 
  # Define the Kubernetes namespace in which the services will be deployed.
  # This namespace should already exist or be created prior to deployment.
  namespace: redpoint-rpi

  # Set the number of replicas for the deployment.
  # This determines how many instances of each pod will be created.
  replicaCount: 1

  # Specify the image tag for the main application.
  # This tag refers to a specific version of the docker image to be deployed.
  image_tag: 7.2.2023-1208-1914

  # Specify the image tag for the documentation service.
  # Similar to 'image_tag', this refers to the docker image version for the docs service.
  image_tag_docs: 7.2.2023-0927-1017

  # Select the cloud provider where the infrastructure is hosted.
  # Options include 'azure', 'google', or 'amazon'.
  # This setting may influence certain cloud-specific configurations.
  cloudProvider: azure
  deploymentType: client
  # Define the deployment type.
  # 'client' is for external clients, while 'internal' is reserved for Redpoint users.
  # This may affect access controls and available features.
  imagePullPolicy: Always
  nodeSelector: {}
  # The nodeSelector is used to specify the nodes where RPI should be deployed.
  # In this case, 'app: {{ .Values.global.nodeSelector.app }}' label is used to ensure RPI is deployed on nodes labeled for Redpoint RPI.
  # This can be particularly useful for directing RPI to specific types of hardware or nodes with certain capabilities.
#    app: redpoint-rpi
  tolerations: {}
  # Tolerations are used in Kubernetes to allow (or 'tolerate') pods to be scheduled on nodes with matching taints.
  # They are key to ensuring that pods are deployed on appropriate nodes.
  # Here, the toleration is set to allow the RPI to be scheduled on nodes with a taint of 'app: {{ .Values.global.nodeSelector.app }}'.
  # The effect 'NoSchedule' indicates that the RPI should not be scheduled on nodes without this specific taint.
  # This configuration ensures that RPI is deployed on nodes specifically designated for Redpoint RPI,
  # possibly for reasons such as specific hardware, security policies, or network configurations.
#    - effect: NoSchedule
#      key: app
#      operator: Equal
#      value: redpoint-rpi

appsettings:
  interactionapi:
    EnableRPIAuthentication: true 
    EnableSwagger: true 
    RPIAuthentication:
      UseTemporaryCredentials: false
      UseCertificateFilePath: false 
      UseCertificateThumbprint: false
      CertificateThumprint: ""
      CertificateFilePath: ""
      CertificateFilePassword: ""
    OpenIdProviders: {}
    EnableSwagger: true 

  configeditor:
    EnableDemoSQLServer: false
    ConnectionSettings:
      # Specify the SQL server address. 
      # This should be the hostname or IP address of your SQL server instance.
      Server: sql-rpi-ops

      # Define the username for the SQL server connection.
      # Ensure this user has the necessary permissions for the operations required.
      Username: sa

      # Provide the password for the SQL server connection.
      # Note: Store passwords securely and avoid hardcoding sensitive information in configuration files.
      Password: MyC0m9l&xP@ssw0rd

      # Name of the database used for logging purposes.
      LoggingDatabaseName: Pulse_Logging

      # Name of the primary operational database.
      PulseDatabaseName: Pulse

      # Specify the type of database being connected to.
      # Supported types: AzureSQLDatabase, AmazonRDSSQL, PostgreSQL, SQLServer, GoogleCloudSQL
      DatabaseType: AzureSQLDatabase
      SelectedDBType: AzureSQLDatabase
      
      # Connection string for the Logging database.
      # Ensure this string matches your database's connection requirements, including the correct server address, database name, and credentials.
      ConnectionStrings_LoggingDatabase: Server=tcp:sql-rpi-ops,1433;Database=Pulse_Logging;User ID=sa;Password=MyC0m9l&xP@ssw0rd;Encrypt=True;TrustServerCertificate=True;Connection Timeout=30;

      # Connection string for the Operational database.
      # Similar to the Logging database, this string should be configured to match the specific requirements of the Operational database.
      ConnectionStrings_OperationalDatabase: Server=tcp:sql-rpi-ops,1433;Database=Pulse;User ID=sa;Password=MyC0m9l&xP@ssw0rd;Encrypt=True;TrustServerCertificate=True;Connection Timeout=30;

  integrationapi:
    EnableRPIAuthentication: false
    DisableHttpRedirect: true 
    OpenIdProviders:
      MetadataHost: ""
      ClientID: rpi
      Name: rgOne
      RedirectURL: ""
      Audience: account
      AuthorizationHost: ""
      EnableRefreshTokens: true 
      CustomScopes: []
      LogoutIdTokenParameter: id_token_hint
      ValidateIssuer: true 
      ValidateAudience: true 

  realtime:
    caches:
      # Specify the connection string for MongoDB.
      # This string is essential for establishing a connection to the MongoDB instance used for caching in real-time operations.
      # Ensure this string includes the necessary authentication details and the correct address of your MongoDB server.
      mongodb_connectionstring:

      # Provide the connection string for the Event Hub.
      # This string is crucial for the real-time service to connect and interact with the Event Hub for event-driven operations.
      # Note: The connection string should include the Event Hub namespace, name, and access key.
      eventhub_connectionstring:

      # Set the name of the Event Hub used by the real-time service.
      # This defines the specific Event Hub instance that the service will use for publishing or subscribing to real-time events.
      eventhub_name: realtimetest

  callbackapi:
    config:
      # Provide the access key for the storage account.
      # This key is used to authenticate and authorize access to the storage account.
      # Ensure that this key is kept secure and has the necessary permissions.
      storage_account_access_key: example-accesskey

      # Specify the name of the storage account.
      # This account will be used by the callback API for storage operations.
      storage_account_name: rpicallbackapi

      # Define the name of the blob container within the storage account.
      # This container is where the callback API will store or retrieve blobs.
      blob_container_name: rpicallbackapi

      # Provide the connection string for the Event Hub.
      # This string is essential for the callback API to connect and interact with the Event Hub.
      # Note: The connection string should include the Event Hub namespace, name, and access key.
      eventhub_connectionstring:

      # Set the name of the Event Hub.
      # This is the Event Hub instance that the callback API will use for publishing or subscribing to events.
      eventhub_name: callbackservice


  executionservice:
    EnableRPIAuthentication: false
    DisableHttpRedirect: true
    RPIExecution__QueueListener__IsEnabled: false 
    RPIExecution__QueueListener__QueuePath: "temporaryplaceholder"
    OpenIdProviders:
      Name: Keycloak
      AuthorizationHost: http://keycloak/auth/realms/RPI
      RedirectURL: redirect-url
      ClientID: rpi
      Audience: account
      CustomScopes: []
      LogoutIdTokenParameter: id_token_hint
      EnableRefreshTokens: true
      ValidateIssuer: true 
      ValidateAudience: true 

  nodemanager:
    EnableRPIAuthentication: false
    DisableHttpRedirect: true
    OpenIdProviders:
      Name: Keycloak
      AuthorizationHost: http://keycloak/auth/realms/RPI
      ClientID: rpi
      Audience: account
      RedirectURL: redirect-url
      EnableRefreshTokens: true
      LogoutIdTokenParameter: id_token_hint
      CustomScopes: []
      ValidateIssuer: true 
      ValidateAudience: true 

  storage:
    # Google Cloud Storage Configuration
    google: 
      # Specify the IP address of your Google Cloud File Store instance.
      # Note: The Google Cloud File Store instance should be created externally 
      # and prior to the deployment of this Helm chart.
      server: 
      # Define the fileshare path where the files will be stored.
      # This path should be set to the mount point or directory within the File Store instance
      # where RPI will read/write files.
        share_name: rpirpifileoutputdir
        path: /rpirpifileoutputdir
      # Set the capacity for the File Store instance.
        capacity: 2056

    # Amazon EFS Configuration
    amazon:
      # Specify the File System ID of your Amazon EFS instance.
      fileSystemId: fs-92107410
      # Set the capacity for the EFS instance.
      capacity: 100Gi
      # Specify the driver for Amazon EFS CSI (Container Storage Interface).
      driver: efs.csi.aws.com

   
ingress:
  # Specify whether the ingress is internal-only.
  # Set to 'true' to restrict access to within the internal network.
  internal: true

  # Define the subnet used by the ingress controller.
  # This should correspond to a specific subnet in your network configuration, typically in a VNET or VPC.
  subnet: snet-aks-workloads

  # Specify the domain name for the ingress resources.
  # This domain will be used to access the services deployed under this ingress.
  domain: example.com

  # Annotations can be used to customize the behavior of the ingress controller.
  # Add any specific annotations required for your ingress setup here.
  annotations: {}

  # Define hostnames for different services in your application.
  # Each entry maps a subdomain of the main domain to a specific service.
  hosts:
    # Config service - Access configuration-related services at 'rpi-config.rdpnt.com'.
    config: redpointrpi-config
    
    # Client service - RPI client login at 'rpi-client.rdpnt.com'.
    client: redpointrpi

    # Integration API - Access integration API at 'rpi-integapi.rdpnt.com'.
    integration: redpointrpi-integrationapi

    # Help Documentation - Access help documents at 'rpi-docs.rdpnt.com'.
    helpdocs: redpointrpi-docs

    # Real-time service - Access real-time services at 'rpi-realtime.rdpnt.com'.
    realtime: redpointrpi-realtime

      
resources:
  limits:
    cpu: "300m"  
    memory: "384Mi" 
  requests:
    cpu: "100m"
    memory: 192Mi

livenessProbe:
  periodSeconds: 20
  timeoutSeconds: 15
  initialDelaySeconds: 300
  failureThreshold: 3
  interaction_api:
    path: /health/live
    port: 8080
  integration_api:
    path: /health/live
    port: 8080

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # #targetMemoryUtilizationPercentage: 80 #

affinity: {}
podAnnotations: {}
podSecurityContext: {}

